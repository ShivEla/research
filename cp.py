# -*- coding: utf-8 -*-
"""cp

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LS_ZF-0mZzP4L_iIhBAWnMtZ_J0JNGpb
"""

from nltk import Tree

from collections import defaultdict

g='''S -> NP VP
PP -> P NP
VP -> V NP
VP -> VP PP
NP -> NP PP
NP -> astronomers
NP -> ears
NP -> saw
V -> saw
NP -> telescope
NP -> stars
P -> with'''

grammar = defaultdict(list)
for line in g.splitlines():
    lhs, rhs = line.strip().split('->')
    lhs = lhs.strip()
    rhs_symbols = rhs.strip().split()
    # Convert RHS to tuple if more than one symbol, else keep as string
    if len(rhs_symbols) == 1:
        key = rhs_symbols[0]
    else:
        key = tuple(rhs_symbols)
    grammar[key].append(lhs)
print(grammar)

from nltk import Tree

def cyk(sentence, g):
    words = sentence.split()
    n = len(words)
    tab = [[[] for _ in range(n)] for _ in range(n)]  # Square matrix (n x n)

    # Fill the diagonal (terminal rules)
    for i, word in enumerate(words):
        for lhs in g.get(word, []):
            tab[i][i].append(Tree(lhs, [word]))

    # Fill the upper triangle (non-terminal combinations)
    for l in range(2, n + 1):  # Length of the span
        for i in range(n - l + 1):  # i is the start index of the span
            j = i + l - 1  # j is the end index of the span
            for k in range(i, j):  # k is the split point
                for left in tab[i][k]:
                    for right in tab[k + 1][j]:
                        rhs = (left.label(), right.label())  # Combine the labels of the subtrees
                        for lhs in g.get(rhs, []):  # Look for rules for this RHS
                            tab[i][j].append(Tree(lhs, [left, right]))

    # Return all full parses starting with 'S'
    return [t for t in tab[0][n - 1] if t.label() == 'S']

# Test sentence
sentence = "astronomers saw stars with ears"

# Parse the sentence using CYK
trees2 = pract_cyk(sentence, grammar)

# Print out the parse tree(s)
for tree in trees2:
    print(tree)
    tree.pretty_print()

from collections import Counter

def prob(trees):
  rule_counts=defaultdict(Counter)
  symbol_counts=Counter()

  for tree in trees:
    for subtree in tree.subtrees():
      if len(subtree)==0:
        continue

      lhs=subtree.label()
      symbol_counts[lhs]+=1

      if all(isinstance(child,str) for child in subtree):
        rhs=subtree[0]
        rule_counts[lhs][rhs]+=1

      else:
        rhs=tuple(child.label() if isinstance(child,Tree) else child for child in subtree)
        rule_counts[lhs][rhs]+=1

  rule_prob={}
  for lhs,rhs_counts in rule_counts.items():
    total=symbol_counts[lhs]
    rule_prob[lhs]={rhs:count/total for rhs,count in rhs_counts.items()}
  print(rule_prob)
  return rule_prob

prob(trees)

treebank_strings = [
        "(S (NP (DT the) (NN cat)) (VP (VBD sat) (PP (IN on) (NP (DT the) (NN mat)))))",
        "(S (NP (DT the) (NN dog)) (VP (VBD chased) (NP (DT the) (NN cat))))",
        "(S (NP (DT a) (NN cat)) (VP (VBD sat) (PP (IN on) (NP (DT the) (NN mat)))))"
    ]

trees=[Tree.fromstring(s) for s in treebank_strings]

def compute(tree,prob):
  if len(tree)==1 and isinstance(tree[0],str):
    lhs=tree.label()
    terminal=tree[0]
    return prob.get(lhs,{}).get(terminal,0.0)

  lhs=tree.label()
  rhs=tuple(child.label() for child in tree)

  rule_prob=prob.get(lhs,{}).get(rhs,0.0)

  children_prob=1.0
  for child in tree:
    children_prob *= compute (child,prob)

  return rule_prob*children_prob

p1=compute(trees2[0] , prob(trees2))
print("1:",p1)
p2=compute(trees2[0] , prob(trees2))
print("2",p2)

